\documentclass{report}
\usepackage{noweb}
\usepackage{amsmath,amsthm} 
\title{Problem Set 01}
\author{Dilawar Singh \\ 
\texttt{dilawar@ee.iitb.ac.in}} 
\date{\today}
\begin{document} \maketitle

\subsection{Import}
<<Import Modules>>=
module Main where
import Prelude

@
\section{Problem 01}
\paragraph{Statement}
Define a function isPrime which accepts a number n, and  returns  True
if n is prime and False otherwise.

The easiest way to test the primality of a number is to  test  whether
it has any  factor.   This  is  usally  done  by  dividing  the  given
number by the smallest prime number i.e. 2 first.  If this divides the
number, we declare that the given number is not prime, else we  repeat
the process with next prime number. 


However this approach requires that we must  have  a  table  of  prime
numbers. It is not possible to use this approach if such table is not
available. To overcome this difficuly, one can choose to simply divide
the given number by integers starting with 2 till one finds a factor.
It has been proven that for a number $N$, one need not test beyond the
integer $\lceil \sqrt{N} \rceil$. 

Let us produce a list of numbers from 2 to $\lceil \sqrt{N} \rceil$ (both
inclusive). Function \texttt{mkList} takes an integer and returns a
list of integers. Note that, we are passing n (type Integer) to a function
\texttt{sqrt} which only works on reals. It is customary to convert it
to real before passing it to function \texttt{sqrt}. We have used
\texttt{fromInteger} for this purpose.

After creating an list of such numbers, we need to test whether any
element of this list divided the given number $N$. Function
[[isAnyFactor]] is written to determine this. It invokes another
function [[isFactor]] which determine whether two numbers are coprime
to each other of not. If they are coprime i.e. one does not divide
other then it return False, else it returns True. Using [[isFactor]]
recursively, we built a list of Boolean values. If all of the elements
of this list are False, then we clain that there is no number between
1 and $\sqrt{N}$ which divides the number $N$, thus, the number is
obviously prime.

One surely can do some tricks. Such as by looking at the last digit,
we can discard all the even numbers and multiple of 5 etc.

<<Problem 01>>=
{- We need to make a list of integers from 2 to square root of N -}

mkList :: Integer -> [Integer]
mkList n = [2..k] 
    where k = toInteger (ceiling $ sqrt $ fromIntegral n )

{- Check if a number divides another number. -}
isFactor :: Integer -> Integer -> Bool
isFactor m n | mod m n == 0 = True
             | otherwise = False

--myMap :: (Integer -> Integer -> Bool) ->  [Integer] -> [Bool]
--myMap f  [] = []
--myMap f  (x:xs) = f x : myMap f xs

{- This function returns array of Bool indicating if the element from
the list created by mkList is a factor of the given number or not. -}

isAnyFactor :: Integer -> [Integer] -> [Bool]
isAnyFactor _ [] = [False]
isAnyFactor z (x:xs) = isFactor z x : isAnyFactor z xs


{- Now test for primality. If a given number is prime, then all of the
elements in the list returned ny isAnyFactor must be False -}
isPrime :: Integer -> Bool
isPrime n = not $ or $ isAnyFactor n (mkList n)

@

\section{Problem 2}
\paragraph{Statement}
A  perfect  number  is  one  whose  factors  add  up  to  itself.
For example 6 and 28 are the  first two perfect numbers.  Write a function
isPerfect that returns True if the input number n is a perfect  number
and False otherwise. 

First we write a function [[getFactors]]. This function will return
all of factors including 1. Then the testing is trivial. We note that
it is enough to test whether any number between 1 and $N/2$ is a
factor of $N$. We collect then in a list and check if the [[sum]] of
this list is equal to the $N$. If yes, then the number is perfect,
otherwise, it is not-perfect I guess.

\paragraph{Note}
This algorith should not be run on large numbers
even if your computer run faster than Chacha Chaudhary's brain.


<<Problem 02>>=
{- Make a list which contains number from 1 to n/2. All of the factor
reside in this range only. -}

mkListAgain :: Integer -> [Integer]
mkListAgain n = [1..k]
    where k = floor ((fromIntegral n)/ 2)

{- Construct a list which contains all factors of n. -}
allFactors :: Integer -> [Integer] -> [Integer]
allFactors _ [] = []
allFactors n (x:xs) | (isFactor n x) == True = x : (allFactors n xs)
                   | otherwise = allFactors n xs

getFactors :: Integer -> [Integer]
getFactors n = allFactors n $ mkListAgain n

{- Now testing is trivial. -}
isPerfect :: Integer -> Bool
isPerfect n | sum (getFactors n) == n = True
            | otherwise = False

@
\section{Problem 3}
\paragraph{Statement}
Write a  function powerFactor which takes two arguments  a and b and
returns the largest n such that

\begin{equation*}
a  =  b^n  *  k \quad  if \quad a \geq  b \\ 
b  =  a^n  *  k \quad otherwise 
\end{equation*}

\pargraph{Solution}
It says that find  $n$ such that $a^n$ divides $b$ if $ a \geq
b$ otherwise swap $a$ and $b$ and find such $n$ again. 

We start from a simple observation that if for any $n$, $a^n$ does not
divide $b$ then no power of $a$ higher than $n$ will do so. We give a
formal proof for this.

\begin{proof} 
If for some $m > 0$, $a^m$ does not divide $b$ then the theorem says
that there exists no $n \geq 1$ such that $a^{m+n}$ divides $b$.
Since $a^m$ divided $b$, we can write
\begin{equation*}
b = n_1 a^m + r_1, \quad where \quad 0 < r_1 < a^m 
\end{equation*}
Now assume that $a^{m+n}$ divides $b$. Then,
\begin{equation*}
b = n_2 a^{m+n} 
\end{equation*}
Combining both of these results, we get
\begin{equation*}
n_1 a^m + r_1 = n_2 a^{m+n} \\
a^m (n_1 - n_2 a^n ) = r_1 \implies 0 < a^n n_2 - n_1 < 1 \\
\end{equation*}
which is not possible since $a^n n_2 - n_1$ is an integer and thus can
have its value between 0 and 1. 
\end{proof}

Now the implementation of this problem. From above proof we have to
find a lowest power of $a$ which divied $b$ and we will keep
increamenting $a^n$ till we get a situation when $a^n$ does not divide
b. If $b \geq a$ then we can swap $a$ and $b$ and use the same
algorithm.

<<Problem 03>>=
powerFact :: Int -> Int ->  [Bool]
powerFact a b | 

@
\subsection{Problem 4}
Simpson’s rule is an accurate  method  of  numerical  integration.
Using Simpson’s rule, the integral of a function f  between  a  and  b
is approximated as

  $h/3* [y_0 + 4*y_1 + 2*y_2 + 4*y_3 + 2*y_4 +...  + 4*y_{n-1}  +
  y_n$

   where $h = (b−a)/n$, for some even integer  n,  and $y_k  =
   f(a+kh)$.  (Increasing  n  increases  the   accuracy   of   the
   approximation.)

Define a procedure simpson that takes as arguments f, a, b, and n  and
returns the value of the  integral, computed using Simpson’s Rule. Use
your procedure to integrate cube between 0 and 1 (with n = 100  and  n
= 1000).

\par

<<Problem 04>>=
simpson :: (Float-> Float) -> Float -> Float -> Integer -> Float
simpson f a b n | mod n 2 == 1 = goodSimpson f a b (n+1)
                | a < b = error "Limit values are insane!"
                | n <= 0 = error "n should be a positive integer."
                | otherwise = goodSimpson f a b n

goodSimpson :: (Float -> Float) -> Float -> Float -> Integer -> Float
goodSimpson f a b n = (h/3) * (sum arraySimpson) 
    where h = (b - a) / (fromIntegral n)
          arraySimpson = makeArraySimpson f a b n h

makeArraySimpson :: (Float -> Float) -> Float -> Float -> Integer -> Float -> [Float]
makeArraySimpson f a b n h 
    = let
        first = f a
        last = f b
        oddArray = mkOArray [1..n`div`2] where
            mkOArray :: [Integer] -> [Float]
            mkOArray [] = []
            mkOArray (x:xs) = (f (a+(2*x-1)*h)) : mkOArray xs

        evenArray = mkEArray [1..n`div`2-1] where
            mkEArray :: [Integer] -> [Float]
            mkEArray [] = []
            mkEArray (x:xs) = (f (a+2.0*x*h)) : mkEArray xs 
    in 
        concat [oddArray, evenArray]
            
cube :: (Float -> Float)
cube x = sqrt x

testSimpson = simpson cube 1.2 2.3 1000
@

5.  Represent a fraction as (Float, Float), and define  the  following
functions:

 (a) makeFraction a b which returns (x,y) such that x/y  is  a  proper
fraction equivalent to a / b. For eg, make fraction 10 4 should return
(5,2).

 (b) numer f and denom f which return the numerator and denominator of
f.

 (c) sum f1 f2 which returns f1+f2.

 (d) equal f1 f2 which returns True if  f1==f2  and  False  otherwise.


<<Problem 05>>=

@
6. Define a function numReverse  n which returns a number whose digits
are the in the reverse order of the  digits  in  n.   numReverse  1234
should   return   4321,   numReverse    120    should    return    21.


<<Problem 06>>=

@
7.  Write a function hasSolution a b  c  which  returns  True  if  the
diophantine equation ax + by = c has solutions for integer values of x
and y. Hint : What condition should  c satisfy with respect to a and b
for a solution to exist?

<<Problem 07>>=

@
8.  The zero of a function f(x) is a value x_0 such that x_0 = f  (x_0
). If x_n is the current approximation of the zero of a function, then
a better  approximation x_{n+1} is  given by:

               x_{n+1}  = x_n −  f (x_n)/f' (x_n )

Use this fact to define a function approxSqrt n  eps  that  finds  the
square root of a number n.  It stops when one approximation is  within
eps of the next.

<<Problem 08>>=

@
9.  Write a function phi  n  representing  Euler’s  totient  function.

In mathematical notation, phi(m) is defined as the number of  positive
integers r(1 <= r <= m) that are coprime to m.  Example: m = 10 has  r
= 1,3,7,9.  Thus phi(10) = 4.
<<Problem 09>>=

@

<<*>>= 
<<Import Modules>> 
<<Problem 01>> 
<<Problem 03>>
<<Problem 04>> 
<<Problem 05>> 
<<Problem 06>> 
<<Problem 07>> 
<<Problem 08>>
<<Problem 09>>

@ 

\end{document}
