\documentclass[]{article}
\usepackage[margin=20mm]{geometry}
\usepackage{amsmath}
\usepackage{tikz,subfig}
\usepackage{noweb}
\usepackage{amsthm}
\usepackage{fontenc}
\usepackage{graphicx}
\usepackage[dvips]{hyperref}
\newtheorem{excercise}{Excercise}
\newtheorem{axiom}{Axiom}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{remark}{Remark}[section]
\newtheorem{definition}{Definition}[section]
\begin{document}
\paragraph{Problem 1}

Write a function $ps :: Integer \rightarrow Integer$ that calculates the number of the
ways in which an n-operand expression can be parenthesized.  For example, $ps 4$
evaluates to 5 because there are 5 ways of parenthesizing a 4-operand
expression, namely $a-(b-(c-d))$, $ a-((b-c)-d)$,
$(a-b)-(c-d)$,$(a-(b-c))-d$,$((a-b)-c)-d$. (extra credit for using list
comprehension).

\paragraph{Discussion}
An expression $a * b$ where $*$ is any binary operation can be considered as a
binary graph with values are its leaf. Such a binary graph represents
parenthesized expression. For three variables, for instance $a$ $b$, and $c$, we
can have two possible parenthesized expressions: $(a+b)+c, a+(b+c)$.

\begin{figure}[h]
\centering
\subfloat[][]{
\begin{tikzpicture}
\coordinate
    child {[fill] circle (2pt) }
    child {[fill] circle (2pt) } 
    ;
\end{tikzpicture}} 
\hspace{5mm}
\subfloat[][]{
\begin{tikzpicture}
\coordinate
    child {[fill] circle (2pt)}
    child { 
        child {[fill] circle (2pt)}
        child {[fill] circle (2pt)}
    }
    ;
\end{tikzpicture}
\hspace{5mm}
\begin{tikzpicture}
\coordinate
    child { 
        child {[fill] circle (2pt)}
        child {[fill] circle (2pt)}}
    child {[fill] circle (2pt)}
    ;
\end{tikzpicture}}
\caption{\small Figure (a) shows encoding of parenthesized expression $(a*b)$ where $*$
is a binary operation. Figure (b) depicts two possible parenthesized version of
three variable expression.  If binary operation is $+$ then figure depicts
$((a+b)+c)$ and $(a+(b+c))$. We assume that permulation of variable is
immaterial i.e. $(a+b)$ and $(b+a)$ are same expressions.}
\label{fig_bin_tree}.
\end{figure}

One can reformulate above problem as \textit{Given $n$ variables, in how many
ways one can construct such binary-trees are showsn in figure
\ref{fig_bin_tree}.}

\begin{theorem}
For given $n > 2$ variables, one can construct $\sum_{x=1}^{n} f(x) \times
f(n-x)$ where $f(1) = f(2) = 1$.
\end{theorem}
\begin{proof}
We prove it by induction. For $n = 2$, there is 
\end{proof}


<<Problem1>>= 

ps :: Int -> Int
ps 1 = 1 -- base case, only one arg, second is nil
ps 2 = 1 -- base case, only two args.
ps n = psHelper [1..(n-1)] 0 -- more than two args. 

psHelper :: [Int] -> Int -> Int
psHelper [] s = s
psHelper (x:[]) s = s + (ps x) * (ps x)
psHelper (x:y:[]) s = s + 2 * (ps x) * (ps y)
psHelper (x:xs) s = psHelper (init xs) (s + 2 * (ps x) * (ps (last xs)))

{- This operation can be coded with list comprehension which  is painfully
slow. -}
psWithList :: Int -> Int
psWithList 1 = 1
psWithList 2 = 1
psWithList n = sum [((psWithList x) * (psWithList (n-x))) | x <- [1..(n-1)]]

@ %def ps psWithList
@
\paragraph{Problem 2}
\begin{verbatim}
      s e n d
    + m o r e
    ----------
    m o n e y
\end{verbatim}
    Here each of the alphabets above  stand for a distinct digit such that
    the resulting addition is correct.  Write a Haskell expression using list
    comprehension  which will  solve  the puzzle  and  give the  following
    output: $[(s,9), (e,5), (n,6), (d,7), (m,1), (o,0),(r,8),(y,2)]$. 

\paragraph{Discussion}

By looking at the solution, we are assuming that this is radix-10 computation.
By the property of radix-10 computation, in any step carry could be either 0 or
1. Thus $m$ is fixed to be 1, and $s + 1 = 10*1 + o$. Depending on whether there
was a carry from the previous computation, one can formulate the possible set of
equations. Since the computation depends on 'if there was a carry', what could
be a better way than a binary-decision diagram to encode the whole computation. 

%\begin{figure}[h]
%\centering
%\begin{tikzpicture}
%\node (1) at (3,10)  [ draw] {$m=1$};
%\node (2) at (1.5,8) [draw] {$s-o=8$};
%\node (3) at (4.5,8) [draw] {$s-o=9$};
%\node (4) at (1.5,6) [draw] {$9o+n=1+e$};
%\node (5) at (4.5,6) [draw] {$9o+n=e$};
%\node (6) at (1.5,4) [draw] {$9n+e=1+r$};
%\node (7) at (4.5,4) [draw] {$9n+e=r$};
%\node (8) at (3,2)   [draw] {$9e+y=d$};
%\draw (1) --  (2);
%\draw [dashed] (1) --  (3);
%\draw (2) -- (4);
%\draw [dashed] (2) -- (5);
%\draw (3) -- (4);
%\draw [dashed] (3) -- (5);
%\draw (4) -- (6);
%\draw [dashed] (4) -- (7);
%\draw (5) -- (6);
%\draw [dashed] (5) -- (7);
%\draw (6) to [bend right] (8);
%\draw (6) to [ dashed] (8);
%\draw (7) to [] (8);
%\draw (7) to [bend left,dashed] (8);
%\end{tikzpicture} 
%\caption{\small Figure shows flow of computation. One starts from the root node
%and traverse the along the graph and collect equations represented by nodes. A
%dashed edge represents the condition that a carry was produced in preceding sum
%while solid edge represents it did not. There are total $8$ such distinct paths,
%    each having $5$ equations. Thus, there could be 8 system of linear
%    equations each containing 5 equations.}
%\end{figure}

\begin{figure}
\centering
\begin{tikzpicture}[level/.style={sibling distance=40mm/#1}, val/.style={circle,draw}]
\foreach \x/\y/\tag in {3/6/1, 1/4/2, 5/4/3}
{
    \node [val] (\tag) at (\x,\y) {$\tag$};
}
\foreach \x/\y/\tag in {0/2/4,2/2/5,4/2/6,6/2/7,0/0/8,2/0/9,4/0/10,6/0/11}
{
    \node [val] (\tag) at(\x,\y)  {$\tag$};
}
\path [->] (1) edge [dashed] (2)
               edge (3)
           (2) edge [dashed] (4)
               edge (5) 
           (3) edge [dashed] (6)
               edge (7)
           (4) edge [dashed, bend right] (8)
               edge [bend left] (8)
           (5) edge [dashed, bend right] (9)
               edge [bend left] (9)
           (6) edge [dashed, bend right] (10)
               edge [bend left] (10)
           (7) edge [dashed, bend right] (11)
               edge [bend left] (11)
           
           ;

\end{tikzpicture}
\end{figure}

<<Problem2>>=



@
@

Q3. Using list comprehension, write a Haskell function queens n which
    will generate all solutions of the n-queens problem.  You may find it useful
    to represent a solution using only column numbers. For example, a solution to
    the 8-queens problem may be \[1,5,8,6,3,7,2,4\] which actually means
    \[(1,1),(2,5),(3,8)...\].

Q4. Let x & y be two integers such that 1 < x < y and x+y < 100. 'A' is given
    the sum (x+y) and 'B' is given their product (x*y).  The following conversation
    happens, A:I dont't know the numbers.  B:I knew that already.  A:Now I know the
    numbers.  B:Now I too know the numbers.  Write a Haskell program to find out the
    numbers. Make use of list comprehension.

Q5. Use the functions map and concat instead of the list comprehension notation
    to deﬁne the following list: [ (x,y+z) | x<-[1..10], y<-[1..x], z<-[1..y] ]


Q6. Implement foldTree for BTree analogous to fold for Lists. The function
    foldBTree has to provide replacement for each constructor. Implement flatten
    using foldTree.

Q7. Write a function isBST :: BTree -> Bool which takes a BTree and returns True
    if it is a Binary Search Tree otherwise returns false.  The function should
    traverse the tree only once.

Q8. We  have  seen  that  expressions  in  C-like  languages
    (uncurried  expressions) can  be represented  as  Gtree Char,
    where Gtree is defined as:

           data   Gtree  a = Gnode  a  [Gtree  a]

    Similarly,  expressions in  Haskell-like  languages in  which
    functions  are  applied  one  argument  at  a  time  (curried
    expressions) can be represented as Btree Char, where Btree is
    defined as:

        data  Btree  a = Leaf  a  |   Bnode  (Btree  a ) (Btree  a)

    Write a  function b_to_g  :: Btree Char  -> Gtree  Char which
    will   take  a  Btree   representation  of   a  Haskell-style
    expression and  convert it into  a Gtree representation  of a
    C-style  expression.  Similarly  write a  function  g_to_b ::
    Gtree Char  -> Btree Char which will  take C-style expression
    and convert it into a Haskell style expression.

<<*>>=
<<Problem1>>
<<Problem2>>
@

\end{document}
